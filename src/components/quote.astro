---
import "../styles/global.css";

const { title, gradient, text, author, color, dataWord } = Astro.props;
---

<section
    class={`quote-section center display ${color === "white" && "white-bg"}`}
>
    <h3 class={`gradient ${gradient}`}>{title}</h3>
    <p class="quote">{text}</p>
    <p class="author" data-word={dataWord}>{author}</p>
</section>

<style>
    .quote-section {
        position: relative;
        flex-direction: column;
        gap: 2rem;
        background-color: var(--black-primary);
        color: var(--white-primary);
    }

    .quote-section > p {
        font-size: 3rem;
    }

    .quote-section > h3 {
        position: absolute;
        font-size: 3rem;
        top: 10rem;
        color: transparent;
    }

    .quote {
        text-align: center;
        font-size: 3rem;
        padding: 0 0.2rem;
        font-weight: 100;
    }

    @media (max-width: 1000px) {
        .quote {
            font-size: 2.2rem !important;
        }
    }

    @media (max-width: 650px) {
        .quote {
            font-size: 1.4rem !important;
            padding: 0 1.5rem;
        }

        .author {
            font-size: 2rem !important;
        }

        .quote-section > h3 {
            font-size: 2rem;
        }
    }

    .white-bg {
        color: var(--black-primary);
        background-color: var(--white-primary);
    }

    .author {
        font-family: KharkivTone;
    }
</style>

<script>
    const authors = document.querySelectorAll(".author");
    const letters = "АБВГҐДЕЄЖЗИІЇЙКЛМНОПРСТУФХЦЧШЩЬЮЯ";

    const randomize = (el) => {
        let iterations = 0;

        const interval = setInterval(() => {
            el.target.innerText = el.target.innerText
                .split("")
                .map((letter, index) => {
                    const currLetter = el.target.dataset.word[index];

                    if (index < iterations) {
                        return currLetter;
                    }

                    if (currLetter === " ") {
                        return currLetter;
                    }

                    return letters[Math.floor(Math.random() * 32)];
                })
                .join("");

            if (iterations >= el.target.dataset.word.length) {
                clearInterval(interval);
            }

            iterations += 1 / 3;
        }, 60);
    };

    authors.forEach((el) =>
        el.addEventListener("mouseover", (e) => randomize(e))
    );

    const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
            if (entry.isIntersecting) {
                randomize(entry);
                observer.unobserve(entry.target);
            }
        });
    });

    authors.forEach((el) => observer.observe(el));
</script>
